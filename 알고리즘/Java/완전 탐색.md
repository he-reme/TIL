# 완전 탐색

* 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법
* Brute-force 혹은 generate-and-test 기법이라고도 불림
  * just do it
  * force의 의미는 사람보다는 컴퓨터의 force를 의미
* 모든 경우의 수를 테스트한 후, 최종 해법을 도출
* 상대적으로 빠른 시간에 문제 해결(알고리즘 설계)을 할 수 있음
* 일반적으로 경우의 수가 상대적으로 작을 때 유용

* 모든 경우의 수를 생성하고 테스트하기 때문에 수행 속도는 느리지만, 해답을 찾아내지 못할 확률이 작음
* 검정 등에서 주어진 문제를 풀 때, **우서 완전 검색으로 접근하여 해답을 도출한 후, 성능 개선을 위해 다른 알고리즘을 사용하고 해답을 확인하는 것이 바람직**하다

#### 완전 탐색 Key Point 

**조합적인 문제들과 연관됨**

* 순열

* 조합

* 부분집합

<br>

---

<br>

## 순열

* 다수의 알고리즘 문제들은 순서화된 요소들의 집합에서 최선의 방법을 찾는 것과 관련 있다
  * TSP (Traveling Salesman Problem)
* N개의 요소들에 대해서 n! 개의 순열들이 존재한다
* {1, 2, 3}을 포함하는 모든 순열을 생성하는 예시

```
import java.util.Arrays;

public class PermutationTest {

	static int N=3, R=3;
	static int[] numbers;
	static boolean[] isSelected;
	
	public static void main(String[] args) {
		
		numbers = new int[R];
		isSelected = new boolean[N+1];
		
		permutation(0);
	}

	private static void permutation (int cnt) {
		
		if(cnt == R) {
			System.out.println(Arrays.toString(numbers));
			return;
		}
		// 가능한 모든 수 시도
		for(int i=1; i<=N; i++) {
			if(isSelected[i]) continue;
			
			numbers[cnt] = i;
			isSelected[i] = true;
			
			// 다음 자리 순열 뽑으로 gogo
			permutation(cnt+1);
			isSelected[i] = false;
		}
	}
}
```

<br>

---

<br>

## 조합

* 서로 다른 n개의 원소 중 r개를 순서 없이 골라낸 것을 조합 이라고 부름
* {1, 4, 7} 에서 재귀호출을 이용한 조합 생성 알고리즘 예시

```java
import java.util.Arrays;

// 실제 N개의 서로 다른 수에서 뽑는 수열
public class CombinationTest {

	static int N=3, R=2;
	static int[] input;
	static int[] numbers;
	static boolean[] isSelected;
	
	public static void main(String[] args) {
		
		input = new int[] {1, 4, 7};
		numbers = new int[R];
		
		
		combination(0, 0);
	}

	private static void combination (int cnt, int start) {
		
		if(cnt == R) {
			System.out.println(Arrays.toString(numbers));
			return;
		}
		// start 위치의 수부터 가능한 수 모두 고려
		for(int i=start; i<N; i++) { // i : 인덱스	
			numbers[cnt] = input[i];
			// 다음 자리 순열 뽑으로 gogo
			combination(cnt+1, i+1);
		}
	}
}

```

