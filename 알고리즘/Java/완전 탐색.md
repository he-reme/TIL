# 완전 탐색

* 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법
* Brute-force 혹은 generate-and-test 기법이라고도 불림
  * just do it
  * force의 의미는 사람보다는 컴퓨터의 force를 의미
* 모든 경우의 수를 테스트한 후, 최종 해법을 도출
* 상대적으로 빠른 시간에 문제 해결(알고리즘 설계)을 할 수 있음
* 일반적으로 경우의 수가 상대적으로 작을 때 유용

* 모든 경우의 수를 생성하고 테스트하기 때문에 수행 속도는 느리지만, 해답을 찾아내지 못할 확률이 작음
* 검정 등에서 주어진 문제를 풀 때, **우서 완전 검색으로 접근하여 해답을 도출한 후, 성능 개선을 위해 다른 알고리즘을 사용하고 해답을 확인하는 것이 바람직**하다

#### 완전 탐색 Key Point 

- **조합적인 문제들과 연관됨**
  - 순열
  - 조합
  - 부분집합
- 구조
  - 유도부분 + 기저부분

<br>

---

<br>

## 순열

* 다수의 알고리즘 문제들은 순서화된 요소들의 집합에서 최선의 방법을 찾는 것과 관련 있다
  * TSP (Traveling Salesman Problem)
* N개의 요소들에 대해서 n! 개의 순열들이 존재한다
* {1, 2, 3}을 포함하는 모든 순열을 생성하는 예시

```java
import java.util.Arrays;

public class PermutationTest {

	static int N=3, R=3;
	static int[] numbers;
	static boolean[] isSelected;
	
	public static void main(String[] args) {
		
		numbers = new int[R];
		isSelected = new boolean[N+1];
		
		permutation(0);
	}

	private static void permutation (int cnt) {
		
		if(cnt == R) {
			System.out.println(Arrays.toString(numbers));
			return;
		}
		// 가능한 모든 수 시도
		for(int i=1; i<=N; i++) {
			if(isSelected[i]) continue;
			
			numbers[cnt] = i;
			isSelected[i] = true;
			
			// 다음 자리 순열 뽑으로 gogo
			permutation(cnt+1);
			isSelected[i] = false;
		}
	}
}
```

<br>

---

<br>

## 조합

* 서로 다른 n개의 원소 중 r개를 순서 없이 골라낸 것을 조합 이라고 부름
* {1, 4, 7} 에서 재귀호출을 이용한 조합 생성 알고리즘 예시

```java
import java.util.Arrays;

// 실제 N개의 서로 다른 수에서 뽑는 수열
public class CombinationTest {

	static int N=3, R=2;
	static int[] input;
	static int[] numbers;
	static boolean[] isSelected;
	
	public static void main(String[] args) {
		
		input = new int[] {1, 4, 7};
		numbers = new int[R];
		
		
		combination(0, 0);
	}

	private static void combination (int cnt, int start) {
		
		if(cnt == R) {
			System.out.println(Arrays.toString(numbers));
			return;
		}
		// start 위치의 수부터 가능한 수 모두 고려
		for(int i=start; i<N; i++) { // i : 인덱스	
			numbers[cnt] = input[i];
			// 다음 자리 순열 뽑으로 gogo
			combination(cnt+1, i+1);
		}
	}
}

```

<br>

---

<br>

## 부분 집합

* 집합에 포함된 원소들을 선택하는 것

* 다수의 중요 알고리즘들이 원소들의 그룹에서 최적의 부분 집합을 찾는 것

* 부분집합의 수

  * 집합의 원소가  n개일 때, 공집합을 포함한 부분집합의 수는 2^n개이다.
  * 이는 각 원소를 부분집합에 포함시키거나 포함시키지 않는 2가지 경우를 모든 원소에 적용한 경우의 수와 같음
  * 예
    * {1, 2, 3, 4} 
    * 2 X 2 X 2 X 2 = 16가지

* 재귀적 구현을 통해 생성하는 방법

  * 각 원소를 부분집합에 포함/비포함의 형태로 재귀적 구현을 함

  ```java
  input[] : 숫자 배열
  isSelected[] : 부분집합에 포함/비포함 여부를 저장한 배열
  
  generateSubSet(cnt) // cnt : 현재까지 처리한 원소 개수
  
  	if(cnt==N)
  		부분집합 완성
      else
      	isSelected[cnt] <- true
      	generateSubSet(cnt+1)
      	isSelected[cnt] <- false
      	generateSubSet(cnt+1)
      	
  end generateSubSet()
  ```

* 부분 집합의 합 문제
  * 유한 개의 정수로 이루어진 집합이 있을 떄, 이 집합의 ㅂ부분집합 중에서 그 집합의 원소를 모두 더한 값이 0이 되는 경우가 있는지 알아내는 문제
    * 완전 검색 기법으로 문제집합 합 문제를 구하기 위해서는, 우선 집합의 모든 부분집합을 생성한 후에 각 부분집합의 합을 계산해야 함

<br>

---

<br>

## 예시

#### 1. 주사위

```java
import java.util.Arrays;
import java.util.Scanner;

public class DiceTest {

	static int N;
	static int[] numbers;
	static int totalCnt;
	static boolean[] isSelected;
	public static void main(String[] args) {
		
		Scanner sc = new Scanner(System.in);
		N = sc.nextInt();
		numbers = new int[N];
		totalCnt = 0;

		int M = sc.nextInt();
		
		switch(M) {
		case 1: // 주사위 던지기1 : 중복 순열
			dice1(0);
			break;
		case 2: // 주사위 던지기2 : 순열
			isSelected = new boolean[7];
			dice2(0);
			break;
		case 3: // 주사위 던지기3 : 중복 조합
			dice3(0, 1);
			break;
		case 4: // 주사위 던지기4 : 조합
			dice4(0, 1);
			break;
		}
		
		System.out.println("경우의 수 : " + totalCnt);
	}


	// 중복 순열
	private static void dice1(int cnt) {
		if(cnt == N) {
			totalCnt++;
			System.out.println(Arrays.toString(numbers));
			return;
		}
		
		for(int i=1; i<=6; i++) {
			numbers[cnt] = i;
			dice1(cnt+1);
		}
	}

	// 순열
	private static void dice2(int cnt) {
		if(cnt == N) {
			totalCnt++;
			System.out.println(Arrays.toString(numbers));
			return;
		}
		
		for(int i=1; i<=6; i++) {
			// 중복 체크
			if(isSelected[i]) continue;
			
			numbers[cnt] = i;
			isSelected[i] = true;
			
			dice2(cnt+1);
			isSelected[i] = false;
		}
	}

	// 중복 조합
	private static void dice3(int cnt, int start) {
		
		if(cnt==N) {
			totalCnt++;
			System.out.println(Arrays.toString(numbers));
			return;
		}
		for(int i=1; i<=6; i++) {
			numbers[cnt] = i;
			dice3(cnt+1, i); // 현재 선택한 수부터 처리하도록
		}
	}
	
	// 조합
	private static void dice4(int cnt, int start) {
		
		if(cnt==N) {
			totalCnt++;
			System.out.println(Arrays.toString(numbers));
			return;
		}
		for(int i=start; i<=6; i++) {
			numbers[cnt] = i;
			dice4(cnt+1, i+1);
		}
	}
}

```

