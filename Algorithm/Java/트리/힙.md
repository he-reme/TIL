# 힙 (heap)

* **완전 이진 트리**에 있는 노드 중에서 키 값이 가장 큰 노드나 키 값이 가장 작은 노드를 찾기 위해서 만든 자료구조

<br>

#### 최대 힙 (max heap)

* 키 값이 가장 큰 노드를 찾기 위한 완전 이진 트리
* 부모 노드의 키 값 > 자식 노드의 키 값
* 루트 노드 : 키 값이 가장 큰 노드

<br>

#### 최소 힙 (min heap)

* 키 값이 가장 작은 노드를 찾기 위한 완전 이진 트리
* 부모 노드의 키 값 < 자식 노드의 키 값
* 루트 노드 : 키 값이 가장 작은 노드

<br>

---

<br>

## 힙 연산

#### 삽입

* 가장 마지막 노드에 삽입 후 부모노드와 비교비교 (logN)

<br>

#### 삭제

* 루트 노드의 원소만을 삭제할 수 있음
* 루트 노드의 원소를 삭제하여 반환, 업데이터
* 힙의 종류에 따라 최대값/최소값 구할 수 있음

* 순서
  1. 루트 노드의 원소값 삭제
  2. 마지막 노드 삭제, 루트에 삽입
  3. 자식노드와 비교하여 자리 바꾸기 (logN)
  4. 자리 확정

<br>

---

<br>

## 우선순위 큐

> 힙의 활용 1

* 우선순위 큐를 구현하는 가장 효율적인 방법이 힙을 사용하는 것
  * 노드 하나의 추가/삭제의 시간 복잡도가 O(logN)
    * 최대값/최소값을 O(1)에 구할 수 있음
  * 완전 정렬보다 관리 비용이 적음
* 배열을 통해 트리 형태를 쉽게 구현 가능
* 삽입할 때 순서가 정해짐

<br>

#### 특성

* 우선순위를 가진 항목들을 저장하는 큐
* FIFO 순서가 아니라 우선순위가 높은 순서대로 먼저 나가게 됨

<br>

#### java.util.PriorityQueue

* Heap 자료구조
* 최대 Heap
  * 가장 큰 값을 기준으로 먼저 나옴
* 최소 Heap
  * 가장 작은 값을 기준으로 먼저 나옴

<br>

#### `java.util.PriorityQueue()`

* 원소들의 natural Ordering에 따라 Heap 유지
  * natural Ordering : 오름차순 / 최소 Heap
    * 원소가 Wrapper, String인 경우

* 따라서, **반드시 모든 원소는 Comparable 인터페이스를 구현해야 함**
  * 정렬 기준 구현!!
* Comparable
  * 나 자신과 param 비교
  * `int compareTo(param)`
  * 리턴
    * 음수
      * 내가 작다
      * natural Ordering (오름차순) : 그대로
    * 0
      * 나랑 같다
      * natural Ordering (오름차순) : 그대로
    * 양수
      * 내가 크다
      * natural Ordering (오름차순) : 교환
  * 내림차순으로 정렬하고 싶으면
    * 리턴 값의 부호를 반대로 만들어주면 됨!!

<br>

#### `java.util.PriorityQueue(Comparator comparator)`

* 명시된 Comparator의 구현에 따라 원소들의 순서를 유지

* Comparator
  * param1과 param2 비교
  * `int compare(param1, param2)`
  * 리턴
    * 음수
    * 0
    * 양수
