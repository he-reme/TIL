# 비트 연산자

* **`&`**
  * 비트 단위로 AND 연산
  * 비트곱
* **`ㅣ`**
  * 비트 단위로 OR 연산
  * 비트합
* `^`
  * 비트 단위로 XOR 연산
  * 같으면 0, 다르면 1
* `~`
  * 단항 연산자
  * 피연산자의 모든 비트를 반전시킴
* **`<<`**
  * 피연산자의 비트열을 왼쪽으로 이동시킴
  * `num << 2`
* `>>`
  * 피 연산자의 비트 열을 오른쪽으로 이동시킴
  * `num >> 2`

<br>

---

<br>

## 응용

#### `value << n`

* value를 n비트 만큼 왼쪽으로 shift
* 왼쪽으로 밀어내고 남은 오른쪽 자리는 0으로 채움
* `10 << 2`
  * 연산 전 : `0 0 0 0 1 0 1 0`
  * 연산 후 : `0 0 1 0 1 0 0 0`

* `1 << 1`
  * 연산 전 : `0 0 0 0 0 0 0 1`
  * 연산 후 : `0 0 0 0 0 0 1 0 `

* `2^3` = `1<<3` 

<br>

#### `value1 & value2`

* value1과 value2를 & 연산

* mask off

* 내가 확인하고 싶은 자리의 **상태를 확인**할 때 사용 !!

  * value2를 통해 자리 선택

* 각 비트열을 비교하여 두 비트 모두 1이면 1, 아니면 0으로 처리

* `10 & 3`

  ```java
    0 0 0 0 1 0 1 0
  & 0 0 0 0 0 1 1 0
  --------------------
  → 0 0 0 0 0 0 1 0
  ```

* `10 & 1<<3`

  ```
    0 0 0 0 1 0 1 0   10
  & 0 0 0 0 1 0 0 0   1<<3
  --------------------
  → 0 0 0 0 1 0 0 0
  ```

  * 10에서 4번째의 상태가 궁금할 때 사용
  * 결과
    * 0이 아님 : 해당 자리가 1이었다~
    * 0임 : 해당 자리가 0이었다~

* `10 & 1<<2`

  ```java
    0 0 0 0 1 0 1 0   10
  & 0 0 0 0 0 1 0 0   1<<2
  --------------------
  → 0 0 0 0 0 0 0 0
  ```

  * 10에서 3번째의 상태가 궁금할 때 사용
  * 결과
    * 0이 아님 : 해당 자리가 1이었다~
    * 0임 : 해당 자리가 0이었다~

<br>

#### `value1 | value2`

* value1과 value2를 | 연산

* mask on

* **특정 자리를 1로 만들고 싶을 때 사용**

* 각 비트열을 비교하여 두 비트 모두 0이면 0, 아니면 1로 처리

* `10 | 3`

  ```java
    0 0 0 0 1 0 1 0
  | 0 0 0 0 0 1 1 0
  --------------------
  → 0 0 0 0 1 1 1 0
  ```

* `10 | 1<<3`

  ```java
    0 0 0 0 1 0 1 0
  | 0 0 0 0 1 0 0 0
  --------------------
  → 0 0 0 0 1 0 1 0
  ```

  * 추가하고 싶은 상태의 자리만 1로 만듬

* `10 | 1<<2`

  ```java
    0 0 0 0 1 0 1 0
  | 0 0 0 0 0 1 0 0
  --------------------
  → 0 0 0 0 1 1 1 0
  ```

<br>

---

<br>

#### `1<< n`

* `2^n`
* 원소가 n개일 경우의 모든 부분집합의 수를 의미함
* Power set (모든 부분 집합)
  * 공집합과 자기 자신을 포함한 모든 부분집합
  * 각 원소가 포함되거나 포함되지 않는 2가지 경우의 수를 계산하면 모든 부분집합의 수가 계산됨
* `1 << 4` = `2^4`

<br>

#### `i & (1 << j)`

* 계산 결과는 i의 j번째가 1인지 아닌지를 의미함

* 예)

  ```java
  public class Test {
  	public static void main(String[] args) {
  		for(int i=-5; i<6; i++) {
  			System.out.printf("%3d=", i);
  			print(i);
  			System.out.println();
  		}
  	}
  	public static void print(int n) {
  		for(int i=7; i>=0; i--) {
  			if((n & (1 << i)) !=0)
              	System.out.printf("1");
  			else 
  				System.out.printf("0");
  		}	
  	}
  }
  ```

  * 결과

    ```java
    -5 = 11111011
    -4 = 11111100
    -3 = 11111101
    -2 = 11111110
    -1 = 11111111
     0 = 00000000
     1 = 00000001
     2 = 00000010
     3 = 00000011
     4 = 00000100
     5 = 00000101
    ```

    

<br>

#### Bit를 이용한 부분 집합 생성

* 원소 수에 해당하는 N개의 비트를 이용
* n번째 비트 값이 1이면 n번째 원소가 포함되었음을 의미
* 예
  * {A, B, C, D}
  * `0000` : {}
  * `0001` : {A}
  * `0010` : {B}
  * `0111` : {A, B, C}
  * ...

<br>

---

<br>

## 응용

#### 비트 마스킹을 통한 순열 생성 

* 비트 연산자를 사용

  ````java
  input[] : 숫자 배열
  numbers[] : 순열 저장 배열
  
  // cnt : 현재까지 뽑은 순열 원소의 개수
  // flag : 선택된 원소에 대한 비트 정보를 표현하는 정수
  perm(cnt, flag)
  	if cnt == N
  		순열 생성 완료
  	else
  		for i from 0 to N-1
  			if (flag & 1<<i) !=0 // 사용 중이면
  				then continue
  			numbers[cnt] ← input[i]
  			perm(cnt+1, flag | 1<<i)
  		end for
  end perm()
  ````

* 분석

  * [ bool 배열 : isSelected ] → [ 정수형 : flag ] 
  * 비트로 상태 표현
    * 0 : 비선택
    * 1 : 선택
  * int 변수 사용하는 경우
    * 32개의 상태 표현 가능
    * `2^32`

* 실행

  * `perm(0,0)`
  * 

<br>