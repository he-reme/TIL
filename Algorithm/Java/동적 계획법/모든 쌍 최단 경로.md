# 모든 쌍 최단 경로

#### 최단 경로 알고리즘

* BFS
  * 가중치 없는 그래프
  * 출발지에서 도착지로의 최단 
* 다익스트라
  * 가중치 있는 그래프
  * 출발지에서 도착지로의 최단
  * 모든 정점에서 출발하여 모든 다른 정점까지의 최단경로를 구함
  * 그래프
    * 인접행렬 : O(N^3)
    * 인접리스트 

* 플로이드워샬
  * 다익스트라에 비해 코드가 심플하고 잘 안틀려서 많이 사용함
  * 3중 for문 : O(N^3)

<br>

#### 최단 경로

* 한 도시에서 다른 도시로 가장 빨리 갈 수 있는 경로를 찾는 문제
* 가중치 포함, 방향성 그래프에서 최단경로 찾기
* 최적화 문제
  * 주어진 문제에 대하여 하나 이상의 많은 해답이 존재할 때, 이 가운데에서 가장 최적인 해답을 찾아야하는 문제

<br>

---

<br>

#### 문제 제시 : 모든 쌍 최단 경로

* 다음 각 정점 사이의 최단 경로는 얼마인가?
* 1에서 2까지의 최단 경로 값은 1이며, 1에서 5까지의 최단 경로 값은 4이다.
* 다른 정점 사이의 최단 경로 값들은 얼마인가?

<br>

---

<br>

## brute-force 접근 방법

> 완전 탐색 방법

* 한 정점에서 다른 정점으로의 모든 경로를 구한 뒤, 그들 중에서 최단 경로를 찾는다
* 그래프가 n개의 정점을 가지고 있고, 완전 그래프라고 가정하면
* 한 정점 i에서 어떤 정점 j로 가는 경로들을 다 모아보면, 그 경로들 중에서 나머지 모든 정점을 하나씩은 꼭 거쳐서 가는 경로들도 포함되어 있는데, 그 경로들의 수만 우선 계산해 보자.
* i에서 출발하여 처음에 도착할 수 있는 정점의 가지 수는 `n-2`개이고, 그 중에 하나를 선택하면, 그 다음에 도착할 수 있는 정점의 가지 수는 `n-3`개 이고, 이렇게 계속하여 계산해 보면, 총 경로의 개수는 `(n-2)(n-3)...1 = (n-2)!`이 된다.
* 이 경로의 개수만 보아도 지수보다 훨씬 크므로, 이 알고리즘은 절대적으로 **비효율적**이다!

<br>

---

<br>

## DP 접근 방법

> 플로이드 - 워샬 알고리즘

#### 다익스트라

* brute-force의 문제를 해결한 알고리즘
* 각 정점을 시작점으로 정하여 **다익스트라**의 최단 경로 알고리즘을 수행하면 된다.
  * 이때의 시간복잡도는 인접행렬을 사용하면 O(n^3)이다
  * 단, n은 정점의 수

<br>

#### 플로이드-워샬 알고리즘

* Warshall은 **그래프에서 모든 쌍의 경로 존재 여부를 찾아내는 동적 계획 알고리즘**을 제안했고, Floyd는 이를 변형하여 모든 쌍 최단 경로를 찾는 알고리즘을 고안하였다.

* 따라서 **모든 쌍 최단 경로를 찾는 동적 계획 알고리즘**을 **플로이드-워샬 알고리즘**이라고 한다.

* 시간 복잡도

  * `O(n^3)`

  * 다익스트라의 시간복잡도와 동일
  * 그러나 플로이드 알고리즘은 매우 간단하여 다익스트라 알고리즘을 사용하는 것보다 효율적임!!!

<br>

#### 접근 방법

* 동적 계획 알고리즘으로 모든 쌍 최단 경로 문제를 해결하려면 먼저 **부분문제**들을 찾아야 함
* 이를 위해 일단 그래프의 정점의 수가 적을 때를 생각해보자
  * 그래프에 3개의 정점이 있는 경우
  * 정점 i에서 정점 j까지의 최단 경로를 찾으려면
  * 2가지 경로 중에서 짧은 것을 선택하면 됨
    * 정점i에서 정점j로 직접 가는 경로
    * 정점1을 경유하는 경로
* 또 하나의 중요한  아이디어
  * 경유 가능한 정점들을 정점1로부터 시작하여, 
  * 정점1과 2, 
  * 그 다음엔 정점 1, 2, 3으로 하나씩 추가하여, 
  * 마지막에는 정점 1~n까지의 모든 정점을 경유 가능한 정점들로 고려하면서, 
  * 모든 쌍의 최단 경로의 거리를 계산한다.

<br>

#### 부분문제 정의

* 단, 입력 그래프의 정점을 각각 1, 2, 3, ... , n이라 하자

* `Dij^k` 

  = 정점 {1, 2, ... , k} 만을 경유 가능한 정점들로 고려하여, 정점 i로부터 정점 j까지의 모든 경로 중에서 가장 짧은 경로의 거리

* **주의할 점**
  * 정점1에서 정점k까지의 모든 정점들을 반드시 경유하는 경로를 의미하는 것이 아님

* `k!=i`, `k!=j` 이고, `k=0`인 경우, 정점0은 그래프에 없으므로 어떤 정점도 경유하지 않는 다는 것을 의미
  * 따라서 `Dij^0`은 입력으로 주어지는 **선분(i,j) 의 가중치**
* `Dij^1`은 **정점i에서 정점1을 경유하여 정점j로 가능 경로**와 **정점i에서 정점j로 직접 가는 경로** 중에서 **가장 짧은 거리**

* 따라서 **모든 쌍 i와 j에 대하여 `Dij^1`을 계산하는 것**이 **가장 작은 문제들**이다
  * 단, `i!=1`, `j!=1` 이다.

* 그 다음엔 i에서 정점2를 경유하여 j로 가는 경로의 거리와 `Dij^1` 중에서 짧은 거리를 `Dij^2`로 정한다.
  * 단, 정점2를 경유하는 경로의 거리는 `Di2^1 + D2j^1` 이다.
* 모든 쌍 i와 j에 대하여 `Dij^2`를 계산하는 것이 그 다음으로 큰 부분 문제들이다.
  * 단, `i!=2`, `j!=2` 이다.  

<br>

#### 일반화

* 정점i에서 정점k를 경유하여 j로 가는 경로의 거리와 `Dij^(k-1)` 중에서 짧은 것으로 정한다.
* 단, 정점k를 경유하는 경로의 거리는 `Dik^(k-1) + Dkj^(k-1)`이고, `i!=k`, `j!=k`이다. 

<br>

#### 결론

* 이런 방식으로 k가 1에서 n이 때까지 `Dij^k`를 계산해서
* 플로이드의 모든 쌍 최단 경로 알고리즘
  * 즉, **모든 정점을 경유 가능한 정점들 k로 고려한 모든 쌍 i과 j의 최단 경로의 거리**를 찾는 방식 
  * `Dij^k`

<br>

#### 알고리즘

```
D[i][j] = 정점 i에서 정점 j로의 최소비용
AllPairsShortest(D[][])
	FOR k in 1 → n
		FOR i in 1 → n (단, i!=k)
			FOR j in 1 → n (단, j!=k && j!=i)
				D[i][j] ← min(D[i][k] + D[k][j], D[i][j])
```

* `k`

  * 경유 정점

  * 1 ~ n

* 조건 체크

  * 가중치가 모두 양수라면
    * 조건 체크 굳이 안해도 됨
  * 가중치에 음수가 포함돼 있으면
    * 조건 체그 반드시 해야 함

* `D[i][j]`
  * 초기 : 인접행렬
  * 그 후 갱신하면 : i→j까지 최단 거리

