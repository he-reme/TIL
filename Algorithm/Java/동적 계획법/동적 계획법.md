# 동적 계획법

* **최적화 문제**와 **경우의 수** 문제를 해결하는 알고리즘
  * 최적화 문제
    * 최대, 최소 문제
* 먼저 작은 부분 문제들의 해들을 구하고 이들을 이용하여 보다 큰 크기의 부분 문제들을 해결하여, 최종적으로 원래 주어진 문제를 해결하는 알고리즘 설계 기법

<br>

#### 동적 계획법 적용 가능한 문제의 요건

* 중복 부분 문제 구조
* 최적 부분 문제 구조

<br>

#### 중복 부분 문제 구조

* DP는 큰 문제를 이루는 작은 문제들을 먼저 해결하고 작은 문제들의 최적 해를 이용하여 순환적으로 큰 문제를 해결함
  * 순환적인 관계를 명시적으로 표현하기 위해서 동적 계획법에서는 일반적으로 **점화식**을 사용함
* DP는 **문제의 순환적인 성질 때문에 이전에 계산되어졌던 작은 문제의 해가 다른 어딘가에서 필요**하게 되는데 
* 이를 위해 DP에서는 **이미 해결된 작은 문제들의 해들을 어떤 저장 공간에 저장**하게 됨
* 그리고 이렇게 저장된 해들이 다시 필요할 때 마다 해를 얻기 위해 다시 문제를 재계산하지 않고 table의 참조를 통해서 중복된 계산을 피하게 됨

<br>

#### 최적 부분 문제 구조

* 동적 계획법이 최적화에 대한 어느 문제에나 적용될 수 있는 것은 아님
* 주어진 문제가 **최적화의 원칙**을 만족해야만 동적 계획법을 효율적으로 적용할 수 있음
* 최적화의 원칙
  * 어떤 문제에 대한 해가 최적일 때 그 해를 구성하는 작은 문제들의 해 역시 최적이어야 한다
* 동적 계획법의 방법자체가 큰 문제의 최적 해를 작은 문제의 최적해들을 이용하여 구하기 떄문에 
* 만약 큰 문제의 최적해가 작은 문제들의 최적해들로 구성되지 않는다면 이 문제는 동적 계획법을 적용할 수 없음

* 최적의 원칙이 적용되지 않는 예
  * 최장경로(Longest Path) 문제

<br>

---

<br>

## 메모이제이션

#### 메모이제이션

* 동적 계획법의 핵심이 되는 기술

* 컴퓨터 프로그램을 실행할 때 이전에 계산한 값을 메모리에 저장해서 매번 다시 계산하지 않도록 하여 전체적인 실행속도를 빠르게 하는 기술
* memoization
  * 메모리에 넣기

* 이미 계산 됐나? 메모가 됐나? 판단
  * Y : 메모된 값 사용
  * N : 계산 후 메모하여 저장

<br>

#### 문제점

* 추가적인 메모리 공간이 필요함
* 재귀 함수 호출로 인한 시스템 호출 스택을 사용하게 되고 실행 속도 저하 또는 오버플로우가 발생 발생할 수 있음

<br>

#### 해결법

* 동적 계획법 사용

<br>

---

<br>

## 분할 정복과 동적 계획법 비교

#### 분할 정복

* 연관 없는 부분 문제를 분할함
* 부분문제를 재귀적으로 해결함
* 부분문제의 해를 결합함
* 하향식 방법으로 접근
* 예
  * 병합 정렬
  * 퀵 정렬

<br>

#### 동적 계획법

* 부분 문제들이 연관이 없으면 적용할 수 없음
  * 즉 부분 문제들은 더 작은 부분 문제들을 공유함
* 모든 문제를 한번만 계산하면 결과를 저장하고 재사용함

* 부분 문제들 사이에 의존적 관계가 존재함
  * 이러한 관계는 문제에 따라 다르고, 대부분의 경우 뚜렷이 보이지 않아서 함축적인 순서라고 함

* 상향식 방법으로 접근