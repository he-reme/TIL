# 재귀 호출

#### 반복과 재귀

* 반복과 재귀는 유사한 작업을 수행할 수 있음
* 반복
  * 수행하는 작업이 완료될 때까지 계속 반복
  * 루프 (for/while, do~while 구조)
  * 단위 반복 찾기!
* 재귀
  * 주어진 문제의 해를 구하기 위해 동일하면서 더 작은 문제의 해를 이용하는 방법
  * 하나의 큰 문제를 해결할 수 있는 (해결하기 쉬운) 더 작은 문제로 쪼개고 결과들을 결합
  * 같은 처리 단위 찾기!

<br>

#### 재귀 함수

* 함수 내부에서 직접 혹은 간접적으로 **자기 자신을 호출하는 함수**
* 일반적으로 재귀적 정의를 이용해서 재귀 함수를 구현
  * **기본 부분**과 **유도 파트**로 구성됨
* 재귀적 프로그램을 작성하는 것은 반복 구조에 비해 간결하고 이해하기 쉬움

*  함수 호출은 프로그램 메모리 구조에서 스택을 사용
  * 따라서 재귀 호출은 반복적인 스택의 사용을 의미하며 메모리 및 속도에서 성능저하가 발생함

<br>

---

<br>

## 예시

#### 팩토리얼 재귀 함수

* 재귀적 정의

  * 기본 파트 (basic part)
    * N <= 1 경우, n=1
  * 유도 파트 (inductive part)
    * N > 1, n != n * (n - 1)!

* n!에 대한 재귀 함수

  ```
  int fact (int n) {
  	if(n <= 1) // 기본 파트 
  		return 1;
  	else // 유도 파트
  		return n*fact(n-1);
  }
  ```

<br>

---

<br>

## 반복 또는 재귀?

* 해결할 문제를 고려해서 방법 선택
* 재귀
  * 문제 해결을 위한 알고리즘 설계까 간단하고 자연스러움
  * 추상 자료형 (List, Tree 등) 알고리즘은 재귀적 구현이 간단하고 자연스러운 경우가 많음
* 일반적으로 재귀적 알고리즘은 반복 알고리즘보다
  * 더 많은 메모리와 연산을 필요로 함
  * 따라서 입력 값 n 이 커질수록 재귀 알고리즘은 반복에 비해 비효율적일 수 있음

<br>

#### 재귀

* 종료
  * 재귀 함수 호출이 종료되는 베이스 케이스
* 수행 시간
  * (상대적) 느림
* 메모리 공간
  * (상재적) 많이 사용
* 소스 코드 길이
  * 짧고 간결
* 소스 코드 형태
  * 선택 구조 (if... else)
* 무한 반복시
  * 스택 오버플로

<br>

#### 반복

* 종료
  * 반복문의 종료 조건
* 수행 시간
  * 빠름

* 메모리 공간
  * 적게 사용
* 소스코드 길이
  * 길다
* 소스 코드 형태
  * 반복 구조 (for, while)
* 무한 반복시
  * CPU를 반복해서 점유

<br>

---

<br>

## 재귀 호출 응용

#### 하노이의 탑 전설

