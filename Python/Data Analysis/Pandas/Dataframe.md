# 데이터프레임

> 2차원 배열

#### 데이터프레임 만들기

```python
df = pandas.DataFrame(딕셔너리)
```

* 딕셔너리
  
  * 여러 개의 리스트를 원소로 갖는 딕셔너리를 주로 활용
* 딕셔너리의 값 (리스트) → 시리즈로 변환
  
  * 데이터프레임의 각 열이 됨
* 딕셔너리의 키 → 시리즈의 이름으로 변환
  
* 데이터프레임의 열 이름이 됨
  
* 예시

  ```python
  import pandas as pd
  dict_data = {'c0':[1,2,3], 'c1':[4,5,6], 'c2':[7,8,9], 'c3':[10, 11, 12]}
  df = pd.Dataframe(dict_data)
  ```

#### 출력

* 예쁘게 출력

  ```python
  display(df)
  ```
  * `print(df)` 대신 사용

* 앞에서 부터 n개 출력

  ````python
  df.head(n)
  ````

* 뒤에서 부터 n개 출력

  ```python
  df.tail(n)
  ```

#### 기본 정보 보기

* 정보 확인

  ```python
  df.info()
  ```

* 자료형 확인

  ```
  df.dtypes
  df.열이름.dtypes
  ```

* `(행, 열)` 크기 확인

  ```python
  df.shape
  ```

* 각 열이 가지고 있는 원소 갯수 확인

  ```python
  df.count()
  ```

* 특정 열이 가지고 있는 고유값마다의 갯수 확인

  ```python
  df.열이름.value_counts()
  ```

  * like.. R의 `factor`?
  * 예시 : 직무별 인원수 출력

* 요약 통계량 확인

  ```python
  df.describe()
  ```

  * 옵션
    * `include='all'`
    * 

---



## 행 인덱스 / 열 이름 

#### 설정

```python
pandas.DataFrame(2차원 배열, index=행 인덱스 배열, columns=열 이름 배열)
```

* 2차원 배열 = 리스트 집합

* 유의 사항 : 각 리스트는 행으로 변환됨

* 예시

  ```python
  import pandas as pd
  df = pd.DataFrame([[23, '남', '대학생'], [25, '여', '취준생']], index=['정섭', '혜림'], columns=['나이', '성별', '상태'])
  ```

#### 출력

* `df.index`
  * 행 인덱스 출력

* `df.columns`
  * 열 이름 출력

#### 변경

* `df.rename(index={기존인덱스:새인덱스,...})`
  * 행 인덱스 변경

* `df.rename(columns={기존이름:새이름, ...})`
  * 열 이름 변경

* 행 인덱스 또는 열 이름의 일부를 선택하여 변경 가능.

* 단, 새로운 데이터 프레임 객체를 리턴함
  * 원본 객체를 변경하려면 `inplace=True` 옵션 사용
    * `df.rename(columns={'나이':'연령', '남녀':'성별'}, inplace=True)`



---



## 행

#### 행 선택 ★★

* `iloc`
  * **정수형 위치 인덱스** 사용할 때
  * 범위 지정
    * `df.iloc[start:end]`
    * end 제외
  * 예시
    * 1번행 1번열 출력
      * `df.iloc[0,0]`
    * 3번,4번행의 3열 출력
      * `df.iloc[[2,3],2]`
    * 3번,4번행의 3,4열 출력
      * `df.iloc[[2,3],[2,3]]`
    * 행 범위 지정
      * `df.iloc[1:3, 2]`
    * 열 범위 지정
      * `df.iloc[2, 1:3]`

* `loc`
  * **인덱스 이름**을 기준으로 행 선택할 때
  * 범위 지정
    * `df.loc[start:end]`
    * end 포함

#### 행 추가

* `df.loc['새로운 행 이름'] = 데이터 값 (또는 리스트)`
  * 추가하려는 열 이름 대신 **숫자**도 가능

#### 행 삭제

* `df.drop(행인덱스/리스트, axis=0)`

  * 행 삭제

  * 동시에 여러 행 삭제하려면

    * 리스트 형태로 입력

  * 원본 객체 직접 변경

    * `inplace=True` 옵션 추가

    

---



## 열

#### 열 선택

* `df['열이름']`
* `df[['열이름1', '열이름2', ...]]`
  * 여러 행 지정 선택
* `df.열이름`
  * 열이름이 문자열 형태인 경우만

* `df[::-1]`
  * 역순 출력

#### 열 추가

* `df['추가하려는 열 이름'] = 데이터값`
  * 이 때 모든 행에 데이터값으로 동일한 값이 입력 됨

#### 열 삭제

* `df.drop(열이름/리스트, axis=1)`
  * 열 삭제
  * 동시에 여러 열 삭제하려면
    * 리스트 형태로 입력
  * 원본 객체 직접 변경
    * `inplace=True` 옵션 추가
  * axis 기본값 : `0`
    * 행 삭제



---



#### 원소 값 변경

* `df.iloc[0,3]=3` 
  * `1번째 행`의 `4번째 열` 값을 `80`으로 변경
* `df.loc['혜림','수학'] = 30`
  * `혜림 행`의 `수학 열` 값을 `30`으로 변경
* `df.loc['마이콜', '국어':'수학'] = 100`
  * `마이콜 행`의 `국어, 영어, 수학 열` 값을 모두 `100`으로 변경
* `df.iloc[0,[1,3]] = 50`
  * `0번째 행`의 `2, 4번째 열` 값을 `50`으로 변경
* `df.iloc[0,[1,3]] = 50, 100`
  * `1번째 행`의 `2번째 열` 값은 `50`으로
  * `1번째 행`의 `4번째 열` 값은 `100`으로 변경
* `df.iloc[1, 1:4] = 50`
  * `2번째 행`의 `1~3번째 열` 값을 `50`으로 변경

#### 데이터 프레임 복사

* `df_new = df.copy()`

#### 전치

* `df = df.transpose()`
  * 메소드 활용
* `df = df.T`
  * 클래스 속성 활용



---



## 인덱스 활용

* `df.head(5)`
* `df.tail(5)`
* `df.set_index('열이름')`
  * df의 열 중 하나를 선택하여 행 인덱스로 지정
  * 새로운 데이터프레임 객체 반환
    * `inplace=True` 사용 가능

* `df.reindex(새로운 인덱스 리스트)`
  * 데이터프레임의 행 인덱스를 새로운 배열로 재지정
  * 기존 데이터프레임에 존재하지 않는 행 인덱스가 새롭게 추가되는 경우, 그 행의 데이터값은 `NaN(결측치)`로 채워짐
    * `fill_value=0` 사용 가능
  * 새로운 데이터프레임 객체를 반환
    * `inplace=True` 사용 가능
* `df.reset_index()`
  * 행 인덱스 초기화
    * 정수형 위치 인덱스로 초기화
  * 기존행 인덱스는 열로 이동
  * 새로운 데이터프레임 객체를 반환
    * `inplace=True` 사용 가능



---



## 정렬

* `df.sort_index()`
  * 행 인덱스를 기준으로 정렬
  * `ascending` 옵션
    * `True` : 오름차순 (기본값)
    * `False` : 내림차순
  * 새롭게 정렬된 데이터프레임 객체 반환
    * `inplace=True` 사용 가능 : 원본에 적용

* `df.sort_values(by='열이름')`
  * 열 기준으로 정렬
  * `ascending` 옵션
    * `True` : 오름차순 (기본값)
    * `False` : 내림차순
  * 새롭게 정렬된 데이터프레임 객체 반환
    * `inplace=True` 사용 가능 : 원본에 적용



---



## 연산

> 연산자 : `+` `-` `*` `/` 
>
> 행/열 인덱스를 기준으로 정렬하고, 일대일 대응되는 원소끼리 연산

#### 데이터프레임 vs 숫자

`df + 연산자 + 숫자`

* 모든 원소에 연산을 함
* 기존 데이터프레임의 형태를 그대로 유지한 채, 원소 값만 새로운 값으로 변환됨

#### 데이터프레임 vs 데이터프레임

`df1 + 연산자 + df2`

* 각 데이터프레임의 같은 행, 같은 열 위치에 있는 원소끼리 계산
* 동일한 위치의 원소끼리 계산한 결과값을 원래 위치에 다시 입력하여 데이터프레임을 만듬

* 대응되는 것이 없으면 `NaN`으로 채워짐
  * 예시
    * `df1` : 열A, 열B, 열C
    * `df2` : 열A, 열B
    * `df1 + df2` : 열A, 열B, 열C
      * 열C의 값들은 모두 `NaN`으로 채워짐

#### 연산 메소드 활용

* 객체 사이에 공통 인덱스가 없는 경우 `NaN`으로 반환하는 상황을 피하기 위해 사용
* 연산 메소드에 `fill_value` 옵션 설정
  * `fill_value = NaN일 경우 채울 값`

* 연산 메소드
  * `df1.add(df2, fill_value=0)`
  * `df1.sub(df2, fill_value=0)`
  * `df1.mul(df2, fill_value=0)`
  * `df1.div(df2, fill_value=0)`



---



## 통계 함수 적용

#### 인덱스 마다의 합

```python
df.sum()
```

#### 평균값

* 모든 열의 평균값

  ```python
  df.mean()
  ```

* 특정 열의 평균값

  ```python
  df['열이름'].mean()
  ```

#### 중간값

* 모든 열의 중간값

  ```python
  df.median()
  ```

* 특정 열의 중간값

  ```python
  df['열이름'].median()
  ```

#### 최대값

* 모든 열의 최대값

  ```python
  df.max()
  ```

* 특정 열의 최대값

  ```python
  df['열이름'].max()
  ```

#### 최소값

* 모든 열의 최소값

  ```python
  df.min()
  ```

* 특정 열의 최소값

  ```python
  df['열이름'].min()
  ```

#### 표준편차

* 모든 열의 표준편차

  ```python
  df.std()
  ```

* 특정 열의 표준편차

  ```python
  df['특정열'].std()
  ```

#### 상관계수

* 모든 열의 상관계수

  ```python
  df.corr()
  ```

* 특정 열의 상관계수

  ```python
  df[['특정열1', '특정열2']].corr()
  ```

#### 람다 함수 사용

```python
df.columns.map(lambda x : str(x)+'년')
```



---



## NaN 값 처리

* 누락값(NaN)을 0으로 채움

  ```python
  df.fillna(0, inplace=True)
  ```

* 누락값(NaN)을 앞 데이터로 채움

  ```python
  df = df.fillna(method='ffill')
  ```

  * 병합된 부분이어서 NaN으로 값이 들어간 경우

