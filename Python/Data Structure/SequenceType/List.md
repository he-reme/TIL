# 리스트

> `list = [1, 2, 3]`
>
> 튜플과 다르게 가변
>
> 시퀀스형



---



## 요소 유무 확인

### (1) `요소 in 리스트`

* 리스트 안에 요소가 있는 경우, True
* 리스트 안에 요소가 없는 경우, False

  

### (2) `요소 not in 리스트` 

* 리스트 안에 요소가 있는 경우, False
* 리스트 안에 요소가 없는 경우, True



---



## 기본 연산

> `list1 = [1, 2, 3, 4, 5, 6]`
>
> `list2 = [10, 11]`

### (1) `+` 연산

* 두개의 리스트를 붙임
* `listAdd = list1 + list2`
  * `[1, 2, 3, 4, 5, 6, 10, 11]`
  * 

### (2) `*` 연산

* 리스트를 숫자만큼 반복해 연장

* `listMulti = list2 * 3`	
  * ` [10, 11, 10, 11, 10, 11]`



---



## 인덱싱

### (1) `list[index]`

* 인덱스 부분 추출



---



## 슬라이싱

### (1) `list[start:end+1:step]`

* `start` 
  * 시작 인덱스
  * defualt는 0
* `end+1`
  * 끝 인덱스
  * default는 리스트의 맨 마지막
* `step`
  * default는 1
  * -1로 지정시 뒤집기
* **예시**
  * `list[1:]`
    * 1부터 끝
  * `list[:3]`
    * 처음부터 2까지
  * `list[::-1]`
    * 역순



---



## 리스트에 데이터 대입

> 기존의 것을 대신해 대입함



### (1) 인덱스를 사용한 대입

>`list = [1, 2, 3, 4, 5, 6]`

* `list[인덱스] = 값`
  * `list[2] = 55    `
    * `[1, 2, 55, 4, 5, 6 ]`
* `list[인덱스] = 리스트`
  * `list[2] = [55, 66]` 
    * `[1, 2, [55, 66], 4, 5, 6]`  
  * **리스트 형태로 대입됨**
  * 

### (2) 슬라이싱을 사용한 대입

> `list = [1, 2, 3, 4, 5, 6]`

* `list[n:n] = 리스트`
  * n 인덱스에 기존의 것을 삭제하지 않고 단순 삽입한다.
  * `list[0:0] = [100]`
    * `[100, 1, 2, 3, 4, 5, 6]`
* `list[n:m] = 리스트`
  * n부터 m-1인덱스에 있는 것을 대신하여 해당 리스트의 요소들을 삽입한다
  * `list1[1:4] = [20, 30, 40]`
    * `[1, 20, 30, 40, 5, 6]`
  * **리스트 형태가 아닌 값으로 대입됨**



---



##  리스트에 데이터 추가

> 기존의 것을 대신해 대입하는 것이 아닌 데이터 추가

### (1) `append()`

> `list = [1, 2, 3, 4, 5, 6]`

* 맨 끝에 요소를 추가
* `list.append(요소)`
  * `list.append(7)`	
    * [1, 2, 3, 4, 5, 6, 7]



### (2) `insert()`

> `list = [1, 2, 3, 4, 5, 6]`

* 원하는 인덱스에 요소 추가
* `list.insert(인덱스, 요소)`
  * `list.insert(2, 99)`
    * `[1, 2, 99, 3, 4, 5, 6, 7]`



### (3) `extend()`

> `list1 = [1, 2, 3, 4, 5, 6]`
>
> `list2 = [10, 20, 30]`

* 리스트 뒤에 또 다른 리스트로 확장
* `list1.extend(list2)`
  * `[1, 2, 3, 4, 5, 6, 10, 20, 30]`



---



## 리스트의 요소 제거

### (1) 인덱스를 사용한 제거

> `list = [1, 2, 3, 4, 5, 6]`

* `del(list[인덱스])` 혹은 `del list[인덱스]`
  * `del(list[2])`
    * `[1, 2, 4, 5, 6]`
* 만약 `list[인덱스] = []` 를 사용할 경우
  * `list[2] = []`
    * [1, 2, [], 4, 5, 6]



### (2) 슬라이싱을 사용한 제거

> `list = [1, 2, 3, 4, 5, 6]`

* `list[start:end+1] = []`
  * `list[2:5] = []`
    * [1, 2, 6]
* `del(list[start:end+1])` 혹은 `del list[start:end+1]`
  * `del(list[2:5])`
    * [1, 2, 6]



### (3) 값을 이용한 제거

> `list = [1, 2, 3, 2, 4, 5, 6]`

* `list.remove(값)`
  * `list.remove(2)`
    * `[1, 3, 2, 4, 5, 6]`
* 값이 여러 개일 경우 먼저 찾은 값만 제거됨



### (4) 요소를 꺼내고 제거

> `list = [1, 2, 3, 4, 5, 6]`

* `pop(인덱스)`
  * 인덱스의 요소를 반환하고 제거함
  * 인덱스 생략시, 맨 끝의 요소



### (5) 모든 요소 제거

* `list.clear()`



---



## 그 외 여러가지 함수, 메소드(객체가 가지고 있는 함수)

### (1) 원하는 요소의 인덱스(위치) 찾기

> `list = [88, 100, 30, 100, 70, 80, 60]`

* `list.index(요소)`

  * `list.index(100)`
    * `1`
  * 해당 리스트 안에 찾으려는 요소가 여러 개일 경우 먼저 찾은 값의 위치 리턴

  

### (2) 원하는 요소의 갯수 리턴

> `list = [88, 100, 30, 100, 70, 80, 60]`

* `list.count(요소)`

  * `list.count(100)`

    * `2`

    

### (3) 최댓값 리턴

* `max(list)`



### (4) 최솟값 리턴

* `min(list)`



### (6) 정렬

* `list.sort()`

  * 오름차순으로 정렬

* 정렬 조건 설정

  * `list.sort(key=조건)`

    * `key` : 정렬 시 요소 비교할 키 추출

  * 예시

    ````
    list.sort(key=str.lower)    #오름차순으로
    list.sort(key=len)    # 길이가 짧은 순으로
    ````

* `new_list = sorted(list)`

  * 기존 리스트를 그대로 두고 정렬된 새로운 리스트 만들기

  

### (5) 역순으로 정렬

*  `list.reverse()`



### (6) 리스트 사본 만들기

> 리스트는 단순히 `=`를 사용할 경우 같은 메모리 공간을 참조하게 됨.
>
> 따라서 사본을 만들기 위해서는 `copy 메서드` 또는 `list[:]`를 사용해야 함

* `new_list = old_list.copy()` ---- `import copy`
* `new_list = old_list[:]`

* 리스트가 가지고 있는 서브 리스트까지 사본으로 만들고 싶으면
  * `new_list = copy.deepcopy(old_list)`
* `is`연산자
  * 두 변수가 같은 객체를 가리키는지 조사 (값을 비교하는 것이 아닌 메모리 주소를 비교)
    * 같으면 `True`, 다르면 `False` 반환
  * `list1 is list2`
  * 그냥 끄적.. (무시해도 상관 없음) 
    * 파이썬은 인터프리터가 구동될 때 **-5부터 256**까지의 정수값은 특정 메모리 주소에 저장하기 때문에 이 값을 가진 변수들은 모두 같은 메모리를 참조하고 있음 ㅎㅎ



---



## 이차원 리스트

> `kor_score = [49, 79, 20, 100, 80]`
>
> `math_score = [43, 59, 85, 30, 90]`
>
> `eng_score = [49, 79, 48, 60, 100]`

* `list = [list1, list2, list3]`
  * `midterm_score = [kor_score, math_score, eng_score]`
    * `[[49, 79, 20, 100, 80], [43, 59, 85, 30, 90], [49, 79, 48, 60, 100]]`

* 이차원 리스트에 인덱싱하여 값에 접근하기
  * `list[i][j]`



---



## 리스트 형식으로 변환

### `list(리스트)`