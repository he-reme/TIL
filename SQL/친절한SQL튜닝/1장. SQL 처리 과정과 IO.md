# 1장. SQL 처리 과정과 I/O

#### 목차
1. SQL 파싱과 최적화
2. SQL 공유 및 재사용
3. 데이터 저장 구조 및 I/O 메커니즘

<br>

---

<br>

## 1. SQL 파싱과 최적화
### [ SQL / 옵티마이저 / SQL 최적화 ]
#### SQL
* Sturectured Query Language
* 구조적, 집합적, 선언적 질의 언어

#### 옵티마이저
* DBMS 내부 엔진
* 사용자가 원하는 작업을 가장 효율적으로 수행할 수 있는 최적의 데이터 엑세스 경로를 선택해주는 핵심 엔진
* 결과 집합은 구조적, 집합적으로 선언하지만 그 결과 집합을 만드내는 프로시저가 필요한데, 그런 프로시저를 만들어 내는 것이 SQL 옵티마이저
* 옵티마이저가 프로그래밍을 대신해주는 셈

#### SQL 최적화
* DBMS 내부에서 프로시저를 작성하고 컴파일해서 실행 가능한 상태로 만드는 전 과정

<br>

### [ SQL 최적화 ]
#### 최적화 과정
1. SQL 파싱
   * 사용자로부터 SQL을 전달 받으면, SQL 파서가 파싱 진행
   * 파싱 트리 생성 → Syntax 체크 (문법적 오류) → Semantic 체크 (의미상 오류)
2. SQL 최적화
   * 옵티마이저가 수집한 통계정보를 바탕으로 다양한 실행경로 생성/비교 후 선택
3. 로우 소스 생성
   * 옵티마이저가 선택한 실행경로를 실제 실행 가능한 코드 또는 프로시저 형태로 포멧팅하는 단계
  
<br>

### [ SQL 옵티마이저 ]
#### 옵티마이저의 최적화 단계
1. 사용자로부터 전달받은 쿼리를 수행하는 데 후보 실행계획들을 찾아냄
2. 데이터 딕셔너리에 미리 수집해둔 오브젝트/시스템 통계정보를 이용해 각 실행계획의 예상비용 산정
3. 최저 비용 실행계획 선택

<br>

### [ 실행계획과 비용 ]
#### 실행계획
* 옵티마이저가 생성한 처리 절차를 사용자가 확인할 수 있게 트리 구조로 표현한 것
<img width="549" height="174" alt="image" src="https://github.com/user-attachments/assets/26d6e05f-8339-4e9a-85f9-eed6e14affef" />

#### 비용(Cost)
* 옵티마이저가 실행경로를 선택하는 근거
* 쿼리를 수행하는 동안 발생할 것으로 예상하는 I/O 횟수 또는 예상 소요시간을 표현한 값

<br>

### [ 옵티마이저 힌트 ]
* 옵티마이저도 가끔 한계가 있기 때문에 힌트를 이용해 데이터 엑세스 경로를 바꿀 수 있음
* 업무 내용은 옵티마이저는 모르고 개발자만 알고 있기 때문
#### 힌트 사용법
* 주석 기호에 '+' 붙이기
* 예시 : /*+ INDEX(컬럼) */
#### 힌트 사용 시 주의사항
* 힌트 안에 인자는 ','(콤마)를 사용할 수 있으나, 힌트와 힌트 사이에는 사용할 수 없음
* 인자의 테이블 지정 시, 스키마명은 명시할 수 없음
* FROM 절 테이블명 앞에 ALIAS를 지정했다면, 힌트의 인자에도 ALIAS를 사용해야 함

<br>

---

<br>

## 2. SQL 공유 및 재사용
### [ 소프트파싱 vs 하드파싱 ]

사용자가 SQL문을 전달하면 DBMS는 SQL을 파싱한 후 해당 SQL이 라이브러리 캐시에 존재하는지부터 확인하는데..

#### 소프트파싱
* 해당 SQL을 라이브러리 캐시에서 찾으면 곧바로 실행단계로 넘어가는 데, 이를 소프트 파싱이라고 함

#### 하드 파싱
* 해당 SQL을 라이브러리 캐시에서 찾지 못하면 최적화 및 로우 소스 생성 단계까지 모두 거쳐야 하는데, 이를 하드 파싱이라고 함

<img width="548" height="215" alt="image" src="https://github.com/user-attachments/assets/a66e6bb2-8268-4562-9dbf-af5e11253ad6" />

<br>

라이브러리 캐시?
* SQL 파싱, 최적화, 로우 소스 생성 과정을 거쳐 생성한 내부 프로시저를 반복 재사용할 수 있도록 캐싱해 두는 메모리 공간
* 라이브러리 캐시는 SGA 구성요소
  * SGA : System Global Area, 서버 프로세스와 백그라운드 프로세스가 공통으로 액세스하는 데이터와 제어 구조를 캐싱하는 메모리 공간
  * <img width="460" height="243" alt="image" src="https://github.com/user-attachments/assets/fc10e3e5-5d56-46e6-a70c-428999f086f6" />
* 라이브러리 캐시가 필요한 이유 : 하드 파싱으로 생성한 프로시저(최적화라는 어려운, 하드한 작업을 거쳐 생성한 내부 프로시저)를 한 번만 사용하고 버린다면 이렇게 비효율 적일 수가 없지..

<br>

SQL 최적화 시, 옵티마이저가 사용하는 정보
* 테이블, 컬럼, 인덱스 구조에 관한 기본 정보
* 오브젝트 통계 : 테이블, 인덱스, 컬럼 통계
* 시스템 통계 : CPU 속도, Single Block I/O 속도, Multiblock I/O 속도 등
* 옵티마이저 관련 파라미터

<br>

### [ 바인드 변수의 중요성 ]

보통 오브젝트는 컴파일 한 상태로 딕셔너리에 저장되고, 실행할 때 라이브러리 캐시에 적재되며 여러 사용자가 공유하면서 재사용을 함.

SQL 또한 처음으로 실행할 때 라이브러리 캐시에 적재됨 (SQL 전체 텍스트가 적재됨)

그러나.. 오브젝트처럼 SQL을 영구 저장해서 사용할 수 없음 (변수가 계속 달라지면 텍스트가 달라지기 때문)

#### 바인드 변수

